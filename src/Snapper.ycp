/* ------------------------------------------------------------------------------
 * Copyright (c) 2006-2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Snapper.ycp
 * Summary:	Snapper settings, input and output functions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of snapper.
 * Input and output routines.
 */

{

module "Snapper";
textdomain "snapper";

import "FileUtils";
import "Label";
import "Progress";
import "Report";
import "String";

// global list of all snapshot
global list<map> snapshots	= [];

global map selected_snapshot	= $[];

// mapping of snapshot number to index in snapshots list
global map<integer,integer> id2index	= $[];

// index to snapshots list
global integer selected_snapshot_index	= 0;

// list of configurations
global list<string> configs	= [ "root" ];

global string current_config	= "root";

/**
 * Return map of files modified between given snapshots
 * Return structure has just one level, and maps each modified file to it's modification map
 */
global map<string,map> ReadModifiedFilesIndex (integer from, integer to) {
    return (map<string,map>) SCR::Read (.snapper.diff_index, $[ "from" : from, "to" : to]);
}

/**
 * Return map of files modified between given snapshots
 * Map is recursively describing the filesystem structure; helps to build Tree widget contents
 */
global map<string, map> ReadModifiedFilesMap (integer from, integer to) {
    return (map<string, map>) SCR::Read (.snapper.diff_tree, $[ "from" : from, "to" : to]);
}

/**
 * Return the path to given snapshot
 */
global string GetSnapshotPath (integer snapshot_num) {
    string ret	= (string) SCR::Read (.snapper.path, $[ "num" : snapshot_num ]);
    if (ret == nil)
    {
	ret	= "";
	// popup error
	Report::Error (sformat (_("Snapshot '%1' was not found."), snapshot_num));
    }
    return ret;
}

/**
 * Return the full path to the given file from currently selected configuration (subvolume)
 * @param file path, relatively to current config
 * GetFileFullPath ("/testfile.txt") -> /abc/testfile.txt for /abc subvolume
 */
global string GetFileFullPath (string file) {

    return snapshots[selected_snapshot_index,"files_index",file,"full_path"]:file;
}

/**
 * Describe what was done with given file between given snapshots
 * - when new is 0, meaning is 'current system'
 */
global map GetFileModification (string file, integer old, integer new) {

    map ret	= $[];
    string file1	= sformat ("%1%2", GetSnapshotPath (old), file);
    string file2	= sformat ("%1%2", GetSnapshotPath (new), file);
    if (new == 0)
    {
	file2	= GetFileFullPath (file);
    }

    y2milestone ("comparing '%1' and '%2'", file1, file2);

    if (FileUtils::Exists (file1) && FileUtils::Exists (file2))
    {
	list<string> status	= [ "no_change" ];
	map out	= (map) SCR::Execute (.target.bash_output,
	    sformat ("/usr/bin/diff -u '%1' '%2'", String::Quote (file1), String::Quote (file2)));
	if (out["stderr"]:"" != "")
	{
	    y2warning ("out: %1", out);
	    ret["diff"] = out["stderr"]:"";
	}
	// the file diff
	else if (out["stdout"]:nil != "")
	{
	    status	= ["diff"];
	    ret["diff"]	= out["stdout"]:"";
	}

	// check mode and ownerships
	out = (map) SCR::Execute (.target.bash_output,
	    sformat ("ls -ld -- '%1' '%2' | cut -f 1,3,4 -d ' '",
	    String::Quote (file1), String::Quote (file2)));
	list<string> parts	= splitstring (out["stdout"]:""," \n");

	if (parts[0]:"" != parts[3]:"")
	{
	    status		= add (status, "mode");
	    ret["mode1"]	= parts[0]:"";
	    ret["mode2"]	= parts[3]:"";
	}
	if (parts[1]:"" != parts[4]:"")
	{
	    status		= add (status, "user");
	    ret["user1"]	= parts[1]:"";
	    ret["user2"]	= parts[4]:"";
	}
	if (parts[2]:"" != parts[5]:"")
	{
	    status		= add (status, "group");
	    ret["group1"]	= parts[2]:"";
	    ret["group2"]	= parts[5]:"";
	}
	ret["status"]	= status;
    }
    else if (FileUtils::Exists (file1))
    {
	ret["status"]	= ["removed"];
    }
    else if (FileUtils::Exists (file2))
    {
	ret["status"]	= ["created"];
    }
    else
    {
	ret["status"]	= ["none"];
    }
    return ret;
}

/**
 * Read the list of snapshots
 */
global boolean ReadSnapshots () {

    snapshots		= [];
    list<map> snapshot_maps	= (list<map>) SCR::Read (.snapper.snapshots);
    if (snapshot_maps == nil) snapshot_maps = [];
    integer i	= 0;
    foreach (map snapshot, snapshot_maps, {
	integer id	= snapshot["num"]:0;
	if (id == 0) return; // ignore the 'current system'
	snapshot["name"]	= tostring (id);
	y2debug ("snapshot data: %1", snapshot);
	snapshots	= add (snapshots, snapshot);
	id2index[id]	= i;
	i		= i + 1;
    });
    return true;
}

global map LastSnapperErrorMap () {

    return (map) SCR::Read (.snapper.error);
}


global list<string> ReadConfigs () {

    configs		= (list<string>) SCR::Read (.snapper.configs);
    if (configs == nil)
    {
	// error popup
	Report::Error (_("File /etc/sysconfig/snapper is not available."));
	configs	= [ "root" ];
    }
    if (!contains (configs, "root") && size (configs) > 0)
    {
	current_config	= configs[0]:"root";
    }
    return configs;
}



/**
 * Initialize snapper agent
 * Return true on success
 */
global boolean InitializeSnapper (string config) {

    boolean init	= (boolean) SCR::Execute (.snapper, $[ "config" : config ]);
    if (!init)
    {
	map err_map	= LastSnapperErrorMap ();
	string type	= err_map["type"]:"";
	string details	= _("Reason not known.");
	if (type == "config_not_found")
	{
	    details	= _("Configuration not found.");
	}
	else if (type == "config_invalid")
	{
	    details	= _("Configuration is not valid.");
	}

	y2warning ("init failed with '%1'", err_map);
	// error popup
	Report::Error (sformat (_("Failed to initialize snapper library:
%1"), details));
    }
    return init;

}

/**
 * Modify existing snapshot
 * Return true on success
 */
global boolean ModifySnapshot (map args) {

    boolean success     = (boolean) SCR::Execute (.snapper.modify, args);
    if (!success)
    {
        map err_map     = LastSnapperErrorMap ();
        string type     = err_map["type"]:"";
        string details  = _("Reason not known.");

        y2warning ("modification failed with '%1'", err_map);
        // error popup
        Report::Error (sformat (_("Failed to modify snapshot:
%1"), details));
    }
    return success;
}

/**
 * Create new snapshot
 * Return true on success
 */
global boolean CreateSnapshot (map args) {

    boolean success     = (boolean) SCR::Execute (.snapper.create, args);
    if (!success)
    {
        map err_map     = LastSnapperErrorMap ();
        string type     = err_map["type"]:"";
        string details  = _("Reason not known.");

        if (type == "wrong_snapshot_type")
        {
            details     = _("Wrong snapshot type given.");
        }
        else if (type == "pre_not_given")
        {
            details     = _("'Pre' snapshot was not given.");
        }
        else if (type == "pre_not_found")
        {
            details     = _("Given 'Pre' snapshot was not found.");
        }

        y2warning ("creating failed with '%1'", err_map);
        // error popup
        Report::Error (sformat (_("Failed to create new snapshot:
%1"), details));
    }
    return success;
}

/**
 * Read all snapper settings
 * @return true on success
 */
global boolean Read() {

    /* Snapper read dialog caption */
    string caption = _("Initializing Snapper");

    integer steps = 2;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/3 */
	    _("Read the list of snapshots"),
	], [
	    /* Progress step 1/3 */
	    _("Reading the database..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    Progress::NextStage();

    ReadConfigs ();

    if (!InitializeSnapper (current_config))
    {
	return false;
    }

    ReadSnapshots ();

    Progress::NextStage();
    return true;
}

/**
 * Return the given file mode as octal number
 */
integer GetFileMode (string file) {

    map out = (map) SCR::Execute (.target.bash_output,
	sformat ("/bin/stat --printf=%%a '%1'", String::Quote (file)));
    string mode        = out["stdout"]:"";
    if (mode == nil || mode == "")
	return 644;
    return tointeger (mode);
}

/**
 * Copy given files from selected snapshot to current filesystem
 * @param snapshot_num snapshot identifier
 * @param files list of full paths to files
 * @return success
 */
global boolean RestoreFiles (integer snapshot_num, list<string> files) {

    boolean ret	= true;
    y2milestone ("going to restore files %1", files);

    UI::OpenDialog (`opt (`decorated), `HBox (`HSpacing(1.5), `VBox (
	`HSpacing (60),
	// label for log window
	`LogView (`id (`log), _("Restoring Files..."), 8, 0),
	`ProgressBar (`id (`progress), "", size (files), 0),
	`PushButton (`id (`ok), Label::OKButton ())
    ), `HSpacing (1.5)));

    UI::ChangeWidget (`id (`ok), `Enabled, false);
    integer progress	= 0;
    foreach (string file, files, {

	UI::ChangeWidget (`id (`progress ), `Value, progress);

	string orig	= GetSnapshotPath (snapshot_num) + file;
	string full_path= GetFileFullPath (file);
	string dir	= substring (full_path, 0, findlastof (full_path, "/"));

	if (!FileUtils::Exists (orig))
	{
	    SCR::Execute (.target.bash, sformat ("/bin/rm -rf -- '%1'", String::Quote (full_path)));
	    y2milestone ("removing '%1' from system", full_path);
	    // log entry (%1 is file name)
	    UI::ChangeWidget (`id (`log), `LastLine, sformat (_("Deleted %1\n"), full_path));
	}
	else if (FileUtils::CheckAndCreatePath (dir))
	{
	    y2milestone ("copying '%1' to '%2' (dir: %3)", orig, file, dir);
	    if (FileUtils::IsDirectory (orig) == true)
	    {
		map stat	= (map) SCR::Read (.target.stat, orig);
		if (!FileUtils::Exists (full_path))
		{
		    SCR::Execute (.target.mkdir, full_path);
		}
		SCR::Execute (.target.bash, sformat ("/bin/chown -- %1:%2 '%3'",
		    stat["uid"]:0, stat["gid"]:0, String::Quote (full_path)));
		SCR::Execute (.target.bash, sformat ("/bin/chmod -- %1 '%2'",
		    GetFileMode (orig), String::Quote (full_path)));
	    }
	    else
	    {
		SCR::Execute (.target.bash, sformat ("/bin/cp -a -- '%1' '%2'",
		    String::Quote (orig), String::Quote (full_path)));
	    }
	    UI::ChangeWidget (`id (`log), `LastLine, full_path + "\n");
	}
	else
	{
	    y2milestone ("failed to copy file '%1' to '%2' (dir: %3)", orig, full_path, dir);
	    // log entry (%1 is file name)
	    UI::ChangeWidget (`id (`log), `LastLine, sformat (_("%1 skipped\n"), full_path));
	}
	sleep (100);
	progress        = progress + 1;
    });

    UI::ChangeWidget (`id (`progress ), `Value, progress);
    UI::ChangeWidget (`id (`ok), `Enabled, true);

    UI::UserInput ();
    UI::CloseDialog ();

    return ret;
}


/* EOF */
}
